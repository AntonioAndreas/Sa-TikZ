% * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
% 
% Sa-TikZ package v0.1 * * (C) Claudio Fiandrino 2012
% 
% * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

% * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
% UTILITY
% * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

\def\CalcHeight(#1,#2)#3{%
\pgfpointdiff{\pgfpointanchor{#1}{south west}}{\pgfpointanchor{#2}{north west}}
\pgfmathsetmacro{\myheight}{veclen(\pgf@x,\pgf@y)}
\global\expandafter\edef\csname #3\endcsname{\myheight}
}

% * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
% KEY DEFINITION
% * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

% N is the key representing the number of inputs x number of modules first stage
\pgfmathtruncatemacro\N{10}%
\pgfkeys{/tikz/.cd, N/.initial=10}%
\pgfkeys{/tikz/.cd, N/.store in=\N}%

% N label
\def\Nlabel{N}%
\pgfkeys{/tikz/.cd, N label/.store in=\Nlabel}%

% r1 is the number of modules first stage
% m1 is the number of inputs first stage per module
\pgfmathtruncatemacro\rone{5}%
\pgfkeys{/tikz/.cd, r1/.initial=5}%
\pgfkeys{/tikz/.cd, r1/.store in=\rone}%

% r1 and m1 label
\def\ronelabel{r\ensuremath{_1}}%
\pgfkeys{/tikz/.cd, r1 label/.store in=\ronelabel}%
\def\monelabel{m\ensuremath{_1}}%
\pgfkeys{/tikz/.cd, m1 label/.store in=\monelabel}%

% r2 label
\def\rtwolabel{r\ensuremath{_2}}%
\pgfkeys{/tikz/.cd, r2 label/.store in=\rtwolabel}%

% M is the key representing the number of inputs x number of modules last stage
\pgfmathtruncatemacro\M{10}%
\pgfkeys{/tikz/.cd, M/.initial=10}%
\pgfkeys{/tikz/.cd, M/.store in=\M}%

% M label
\def\Mlabel{M}%
\pgfkeys{/tikz/.cd, M label/.store in=\Mlabel}%


% r3 is the number of modules last stage
% m3 is the number of inputs last stage per module
\pgfmathtruncatemacro\rthree{5}%
\pgfkeys{/tikz/.cd, r3/.initial=5}%
\pgfkeys{/tikz/.cd, r3/.store in=\rthree}%

% r3 and m3 label
\def\rthreelabel{r\ensuremath{_3}}%
\pgfkeys{/tikz/.cd, r3 label/.store in=\rthreelabel}%
\def\mthreelabel{m\ensuremath{_3}}%
\pgfkeys{/tikz/.cd, m3 label/.store in=\mthreelabel}%

% * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
% GENERAL SETTINGS
% * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
\pgfmathtruncatemacro{\modulesize}{1cm}
\pgfkeys{/tikz/.cd, module size/.store in=\modulesize}%

\pgfmathsetmacro{\moduleysep}{1.5}
\pgfkeys{/tikz/.cd, module ysep/.store in=\moduleysep}%

\pgfmathsetmacro{\modulexsep}{3}
\pgfkeys{/tikz/.cd, module xsep/.store in=\modulexsep}%

\tikzset{module/.style={%
		draw,rectangle, minimum size=\modulesize,
	}
}

\tikzset{module extensible/.style={%
		draw,rectangle, minimum size=#1,
	},
	module extensible/.default={\modulesize}
}

\pgfmathsetmacro{\modulelabelopacity}{1}
\pgfkeys{/tikz/.cd, module label opacity/.store in=\modulelabelopacity}%

\tikzset{module opacity/.style={
		text opacity=\modulelabelopacity,
	}
}

\pgfmathtruncatemacro{\pinlength}{1}
\pgfkeys{/tikz/.cd, pin length factor/.store in=\pinlength}%

\tikzset{math mode labels/.style={%
		execute at begin node=$,%
      execute at end node=$,%
	}
}
\pgfkeys{/tikz/.cd, use math mode labels/.is choice}%
\pgfkeys{/tikz/.cd, use math mode labels/true/.style={math mode labels}}%
\pgfkeys{/tikz/.cd, use math mode labels/false/.style={}}%

\tikzset{set math mode labels/.style={%
		use math mode labels=#1,
	},
	set math mode labels/.default=false,
}


% * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
% CODE
% * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *

% CLOS SNB
\tikzset{clos snb/.code={

      % Number of ports per module
      \pgfmathtruncatemacro{\mone}{\N/\rone}
      \pgfmathtruncatemacro{\mthree}{\M/\rthree}

		% COMPUTATION SNB CONDITION
		\pgfmathtruncatemacro\rtwo{\mone+\mthree-1}

		% MODULE 1
		\foreach \i in {1,...,\rone}{
		  	\path let \n1 = {int(0-\i)}, \n2={0-\i*\moduleysep}
		  	in
		  	node[module,#1,module opacity,yshift=1cm]  (r1-\i) at +(0,\n2) {\pgfmathparse{int(multiply(\n1,-1))}\pgfmathresult};
		  	
		  	% INPUTS MODULE 1	
		    % the number of inputs module one is exactly \mone
			\pgfmathsetmacro\roneintervalspace{1/(\mone+1)}		
			\foreach \roneinput[evaluate=\roneinput as \roneinterval using \roneintervalspace*\roneinput] 
			in {1,...,\mone}
			\draw ($(r1-\i.north west)!\roneinterval!(r1-\i.south west)-(0.5*\pinlength,0)$)node[scale=0.1](r1-\i-front input-\roneinput){}--($(r1-\i.north west)!\roneinterval!(r1-\i.south west)$) node[circle,draw,scale=0.1] (r1-\i-input-\roneinput) {};
			
			% OUTPUTS MODULE 1
			% the number of outputs of module one is the number of modules stage 2 \rtwo
			\pgfmathsetmacro\roneintervalspace{1/(\rtwo+1)}
			\foreach \roneoutput[evaluate=\roneoutput as \roneinterval using \roneintervalspace*\roneoutput] 
			in {1,...,\rtwo}
			\node[circle,draw,scale=0.1] (r1-\i-output-\roneoutput)at($(r1-\i.north east)!\roneinterval!(r1-\i.south east)$)  {};
		}
		
		% MODULE 2
		\foreach \i in {1,...,\rtwo}{
		  	\path let \n1 = {int(0-\i)}, \n2={0-\i*\moduleysep}
		  	in
		  	node[module,#1,module opacity,yshift=1cm]  (r2-\i) at +(\modulexsep,\n2) {\pgfmathparse{int(multiply(\n1,-1))}\pgfmathresult};

		  % INPUTS MODULE 2
			% the number of inputs of module two is the number of modules stage 1 \rone
			\pgfmathsetmacro\rtwointervalspace{1/(\rone+1)}
			\foreach \rtwoinput[evaluate=\rtwoinput as \rtwointerval using \rtwointervalspace*\rtwoinput] 
			in {1,...,\rone}
			\node[circle,draw,scale=0.1] (r2-\i-input-\rtwoinput)at($(r2-\i.north west)!\rtwointerval!(r2-\i.south west)$)  {};	
			
			% OUTPUTS MODULE 2
		    % the number of outputs module two is exactly \rthree
			\pgfmathsetmacro\rtwointervalspace{1/(\rthree+1)}		
			\foreach \rtwooutput[evaluate=\rtwooutput as \rtwointerval using \rtwointervalspace*\rtwooutput] 
			in {1,...,\rthree}
			\node[circle,draw,scale=0.1] (r2-\i-output-\rtwooutput)at ($(r2-\i.north east)!\rtwointerval!(r2-\i.south east)$) {};
		  	
		}
		
		% MODULE 3
		\foreach \i in {1,...,\rthree}{
		  	\path let \n1 = {int(0-\i)}, \n2={0-\i*\moduleysep}
		  	in
		  	node[module,#1,module opacity,yshift=1cm]  (r3-\i) at +(2*\modulexsep,\n2) {\pgfmathparse{int(multiply(\n1,-1))}\pgfmathresult};
		  	
		  	% INPUTS MODULE 3
			% the number of inputs of module three is the number of modules stage 2 \rtwo
			\pgfmathsetmacro\rthreeintervalspace{1/(\rtwo+1)}
			\foreach \rthreeinput[evaluate=\rthreeinput as \rthreeinterval using \rthreeintervalspace*\rthreeinput] 
			in {1,...,\rtwo}
			\node[circle,draw,scale=0.1] (r3-\i-input-\rthreeinput)at($(r3-\i.north west)!\rthreeinterval!(r3-\i.south west)$)  {};
		  	
		  	% OUTPUTS MODULE 3	
		    % the number of outputs module three is exactly \mthree
			\pgfmathsetmacro\rthreeintervalspace{1/(\mthree+1)}		
			\foreach \rthreeoutput[evaluate=\rthreeoutput as \rthreeinterval using \rthreeintervalspace*\rthreeoutput] 
			in {1,...,\mthree}
			\draw ($(r3-\i.north east)!\rthreeinterval!(r3-\i.south east)+(0.5*\pinlength,0)$)node[scale=0.1](r3-\i-front output-\rthreeoutput){}--($(r3-\i.north east)!\rthreeinterval!(r3-\i.south east)$) node[circle,draw,scale=0.1] (r3-\i-output-\rthreeoutput) {};
		  	
		}		
		% DRAWING CONNECTIONS
		%% from r1 to r2
		\foreach \startmodule in {1,...,\rone}{
		\foreach \conn in {1,...,\rtwo}
				\draw(r1-\startmodule-output-\conn)--(r2-\conn-input-\startmodule);
		}
		%% from r2 to r3
		\foreach \startmodule in {1,...,\rthree}{
		\foreach \conn in {1,...,\rtwo}
				\draw(r3-\startmodule-input-\conn)--(r2-\conn-output-\startmodule);
		}		
	},
}

\tikzset{clos snb example/.code={

      % Number of ports per module
      \pgfmathtruncatemacro{\mone}{\N/\rone}
      \pgfmathtruncatemacro{\mthree}{\M/\rthree}

		% COMPUTATION SNB CONDITION
		\pgfmathtruncatemacro\rtwo{\mone+\mthree-1}
		
		% MODULE 1
		\node[module,#1,module opacity](r1-1) at (0,0) {1};
		\node[below of=r1-1,yshift=0.75ex](r1-dots) {\vdots};
		\node[module,#1,module opacity,below of=r1-dots](r1-2) {\rone};
		
		\foreach \i in {1,2}{
		   % INPUTS MODULE 1	
		   % just two modules
			\pgfmathsetmacro\roneintervalspace{1/(2+1)}
			\foreach \roneinput[evaluate=\roneinput as \roneinterval using \roneintervalspace*\roneinput] 
			in {1,2}
			\draw ($(r1-\i.north west)!\roneinterval!(r1-\i.south west)-(0.5*\pinlength,0)$)node[scale=0.1](r1-\i-front input-\roneinput){}--($(r1-\i.north west)!\roneinterval!(r1-\i.south west)$) node[circle,draw,scale=0.1] (r1-\i-input-\roneinput) {};
			
			% OUTPUTS MODULE 1
			% just two modules
			\pgfmathsetmacro\roneintervalspace{1/(2+1)}
			\foreach \roneoutput[evaluate=\roneoutput as \roneinterval using \roneintervalspace*\roneoutput] 
			in {1,2}
			\node[circle,draw,scale=0.1] (r1-\i-output-\roneoutput)at($(r1-\i.north east)!\roneinterval!(r1-\i.south east)$)  {};
		}	
		
		% MODULE 2
		\node[module,#1,module opacity](r2-1) at (\modulexsep,0) {1};
		\node[below of=r2-1,yshift=0.75ex](r2-dots) {\vdots};
		\node[module,#1,module opacity,below of=r2-dots](r2-2) {\rtwo};
		
		\foreach \i in {1,2}{
		   % INPUTS MODULE 2
			% just two modules
			\pgfmathsetmacro\rtwointervalspace{1/(2+1)}
			\foreach \rtwoinput[evaluate=\rtwoinput as \rtwointerval using \rtwointervalspace*\rtwoinput] 
			in {1,2}
			\node[circle,draw,scale=0.1] (r2-\i-input-\rtwoinput)at($(r2-\i.north west)!\rtwointerval!(r2-\i.south west)$)  {};	
			
			% OUTPUTS MODULE 2
		   % just two modules
			\pgfmathsetmacro\rtwointervalspace{1/(2+1)}		
			\foreach \rtwooutput[evaluate=\rtwooutput as \rtwointerval using \rtwointervalspace*\rtwooutput] 
			in {1,2}
			\node[circle,draw,scale=0.1] (r2-\i-output-\rtwooutput)at ($(r2-\i.north east)!\rtwointerval!(r2-\i.south east)$) {};
		}
		
		% MODULE 3
		\node[module,#1,module opacity](r3-1) at (2*\modulexsep,0) {1};
		\node[below of=r3-1,yshift=0.75ex](r3-dots) {\vdots};
		\node[module,#1,module opacity,below of=r3-dots](r3-2) {\rthree};
		
		\foreach \i in {1,2}{
		   % INPUTS MODULE 3
			% just two modules
			\pgfmathsetmacro\rthreeintervalspace{1/(2+1)}
			\foreach \rthreeinput[evaluate=\rthreeinput as \rthreeinterval using \rthreeintervalspace*\rthreeinput] 
			in {1,2}
			\node[circle,draw,scale=0.1] (r3-\i-input-\rthreeinput)at($(r3-\i.north west)!\rthreeinterval!(r3-\i.south west)$)  {};
		  	
		  	% OUTPUTS MODULE 3	
		   % just two modules
			\pgfmathsetmacro\rthreeintervalspace{1/(2+1)}		
			\foreach \rthreeoutput[evaluate=\rthreeoutput as \rthreeinterval using \rthreeintervalspace*\rthreeoutput] 
			in {1,2}
			\draw ($(r3-\i.north east)!\rthreeinterval!(r3-\i.south east)+(0.5*\pinlength,0)$)node[scale=0.1](r3-\i-front output-\rthreeoutput){}--($(r3-\i.north east)!\rthreeinterval!(r3-\i.south east)$) node[circle,draw,scale=0.1] (r3-\i-output-\rthreeoutput) {};
		}
		
		% DRAWING CONNECTIONS
		%% from r1 to r2
		\foreach \startmodule in {1,2}{
		\foreach \conn in {1,2}
				\draw(r1-\startmodule-output-\conn)--(r2-\conn-input-\startmodule);
		}
		%% from r2 to r3
		\foreach \startmodule in {1,2}{
		\foreach \conn in {1,2}
				\draw(r3-\startmodule-input-\conn)--(r2-\conn-output-\startmodule);
		}
		
		% SETTING LABELS
		\node[below of=r1-2,set math mode labels] {\mone~\ensuremath{\times}~\rtwo};
		\node[below of=r2-2,set math mode labels] {\rone~\ensuremath{\times}~\rthree};
		\node[below of=r3-2,set math mode labels] {\rtwo~\ensuremath{\times}~\mthree};
		\draw[decorate,decoration={brace}]($(r1-2-front input-2)-(0.1,0)$)--($(r1-1-front input-1)-(0.1,0)$) node[midway,left=0.1cm,set math mode labels]{\N};
		\draw[decorate,decoration={brace}]($(r3-1-front output-1)+(0.1,0)$)--($(r3-2-front output-2)+(0.1,0)$) node[midway,right=0.1cm,set math mode labels]{\M};
	},
}	

% CLOS REAR

\tikzset{clos rear/.code={		

      % Number of ports per module
      \pgfmathtruncatemacro{\mone}{\N/\rone}
      \pgfmathtruncatemacro{\mthree}{\M/\rthree}
		
		% COMPUTATION REAR CONDITION
		\pgfmathtruncatemacro\rtwo{max(\mone,\mthree)}

		% MODULE 1
		\foreach \i in {1,...,\rone}{
		  	\path let \n1 = {int(0-\i)}, \n2={0-\i*\moduleysep}
		  	in
		  	node[module,#1,module opacity,yshift=1cm]  (r1-\i) at +(0,\n2) {\pgfmathparse{int(multiply(\n1,-1))}\pgfmathresult};
		  	
		  	% INPUTS MODULE 1	
		    % the number of inputs module one is exactly \mone
			\pgfmathsetmacro\roneintervalspace{1/(\mone+1)}
			\foreach \roneinput[evaluate=\roneinput as \roneinterval using \roneintervalspace*\roneinput] 
			in {1,...,\mone}
			\draw ($(r1-\i.north west)!\roneinterval!(r1-\i.south west)-(0.5*\pinlength,0)$)node[scale=0.1](r1-\i-front input-\roneinput){}--($(r1-\i.north west)!\roneinterval!(r1-\i.south west)$) node[circle,draw,scale=0.1] (r1-\i-input-\roneinput) {};
			
			% OUTPUTS MODULE 1
			% the number of outputs of module one is the number of modules stage 2 \rtwo
			\pgfmathsetmacro\roneintervalspace{1/(\rtwo+1)}
			\foreach \roneoutput[evaluate=\roneoutput as \roneinterval using \roneintervalspace*\roneoutput] 
			in {1,...,\rtwo}
			\node[circle,draw,scale=0.1] (r1-\i-output-\roneoutput)at($(r1-\i.north east)!\roneinterval!(r1-\i.south east)$)  {};
		}
		
		% MODULE 2
		\foreach \i in {1,...,\rtwo}{
		  	\path let \n1 = {int(0-\i)}, \n2={0-\i*\moduleysep}
		  	in
		  	node[module,#1,module opacity,yshift=1cm]  (r2-\i) at +(\modulexsep,\n2) {\pgfmathparse{int(multiply(\n1,-1))}\pgfmathresult};
		  	
		  	% INPUTS MODULE 2
			% the number of inputs of module two is the number of modules stage 1 \rone
			\pgfmathsetmacro\rtwointervalspace{1/(\rone+1)}
			\foreach \rtwoinput[evaluate=\rtwoinput as \rtwointerval using \rtwointervalspace*\rtwoinput] 
			in {1,...,\rone}
			\node[circle,draw,scale=0.1] (r2-\i-input-\rtwoinput)at($(r2-\i.north west)!\rtwointerval!(r2-\i.south west)$)  {};
			
			% OUTPUTS MODULE 2
		    % the number of outputs module two is exactly \rthree
			\pgfmathsetmacro\rtwointervalspace{1/(\rthree+1)}		
			\foreach \rtwooutput[evaluate=\rtwooutput as \rtwointerval using \rtwointervalspace*\rtwooutput] 
			in {1,...,\rthree}
			\node[circle,draw,scale=0.1] (r2-\i-output-\rtwooutput)at ($(r2-\i.north east)!\rtwointerval!(r2-\i.south east)$) {};
		  	
		}
		
		% MODULE 3
		\foreach \i in {1,...,\rthree}{
		  	\path let \n1 = {int(0-\i)}, \n2={0-\i*\moduleysep}
		  	in
		  	node[module,#1,module opacity,yshift=1cm]  (r3-\i) at +(2*\modulexsep,\n2) {\pgfmathparse{int(multiply(\n1,-1))}\pgfmathresult};
		  	
		  	% INPUTS MODULE 3
			% the number of inputs of module three is the number of modules stage 2 \rtwo
			\pgfmathsetmacro\rthreeintervalspace{1/(\rtwo+1)}
			\foreach \rthreeinput[evaluate=\rthreeinput as \rthreeinterval using \rthreeintervalspace*\rthreeinput] 
			in {1,...,\rtwo}
			\node[circle,draw,scale=0.1] (r3-\i-input-\rthreeinput)at($(r3-\i.north west)!\rthreeinterval!(r3-\i.south west)$)  {};
		  	
		  	% OUTPUTS MODULE 3	
		    % the number of outputs module three is exactly \mthree
			\pgfmathsetmacro\rthreeintervalspace{1/(\mthree+1)}		
			\foreach \rthreeoutput[evaluate=\rthreeoutput as \rthreeinterval using \rthreeintervalspace*\rthreeoutput] 
			in {1,...,\mthree}
			\draw ($(r3-\i.north east)!\rthreeinterval!(r3-\i.south east)+(0.5*\pinlength,0)$)node[scale=0.1](r3-\i-front output-\rthreeoutput){}--($(r3-\i.north east)!\rthreeinterval!(r3-\i.south east)$) node[circle,draw,scale=0.1] (r3-\i-output-\rthreeoutput) {};			
		}
		
		% DRAWING CONNECTIONS
		%% from r1 to r2
		\foreach \startmodule in {1,...,\rone}{
		\foreach \conn in {1,...,\rtwo}
				\draw(r1-\startmodule-output-\conn)--(r2-\conn-input-\startmodule);
		}
		%% from r2 to r3
		\foreach \startmodule in {1,...,\rthree}{
		\foreach \conn in {1,...,\rtwo}
				\draw(r3-\startmodule-input-\conn)--(r2-\conn-output-\startmodule);
		}
		
	}
}



\tikzset{clos rear example/.code={

      % Number of ports per module
      \pgfmathtruncatemacro{\mone}{\N/\rone}
      \pgfmathtruncatemacro{\mthree}{\M/\rthree}

		% COMPUTATION REAR CONDITION
		\pgfmathtruncatemacro\rtwo{max(\mone,\mthree)}
		
		% MODULE 1
		\node[module,#1,module opacity](r1-1) at (0,0) {1};
		\node[below of=r1-1,yshift=0.75ex](r1-dots) {\vdots};
		\node[module,#1,module opacity,below of=r1-dots](r1-2) {\rone};
		
		\foreach \i in {1,2}{
		   % INPUTS MODULE 1	
		   % just two modules
			\pgfmathsetmacro\roneintervalspace{1/(2+1)}
			\foreach \roneinput[evaluate=\roneinput as \roneinterval using \roneintervalspace*\roneinput] 
			in {1,2}
			\draw ($(r1-\i.north west)!\roneinterval!(r1-\i.south west)-(0.5*\pinlength,0)$)node[scale=0.1](r1-\i-front input-\roneinput){}--($(r1-\i.north west)!\roneinterval!(r1-\i.south west)$) node[circle,draw,scale=0.1] (r1-\i-input-\roneinput) {};
			
			% OUTPUTS MODULE 1
			% just two modules
			\pgfmathsetmacro\roneintervalspace{1/(2+1)}
			\foreach \roneoutput[evaluate=\roneoutput as \roneinterval using \roneintervalspace*\roneoutput] 
			in {1,2}
			\node[circle,draw,scale=0.1] (r1-\i-output-\roneoutput)at($(r1-\i.north east)!\roneinterval!(r1-\i.south east)$)  {};
		}	
		
		% MODULE 2
		\node[module,#1,module opacity](r2-1) at (\modulexsep,0) {1};
		\node[below of=r2-1,yshift=0.75ex](r2-dots) {\vdots};
		\node[module,#1,module opacity,below of=r2-dots](r2-2) {\rtwo};
		
		\foreach \i in {1,2}{
		   % INPUTS MODULE 2
			% just two modules
			\pgfmathsetmacro\rtwointervalspace{1/(2+1)}
			\foreach \rtwoinput[evaluate=\rtwoinput as \rtwointerval using \rtwointervalspace*\rtwoinput] 
			in {1,2}
			\node[circle,draw,scale=0.1] (r2-\i-input-\rtwoinput)at($(r2-\i.north west)!\rtwointerval!(r2-\i.south west)$)  {};	
			
			% OUTPUTS MODULE 2
		   % just two modules
			\pgfmathsetmacro\rtwointervalspace{1/(2+1)}		
			\foreach \rtwooutput[evaluate=\rtwooutput as \rtwointerval using \rtwointervalspace*\rtwooutput] 
			in {1,2}
			\node[circle,draw,scale=0.1] (r2-\i-output-\rtwooutput)at ($(r2-\i.north east)!\rtwointerval!(r2-\i.south east)$) {};
		}
		
		% MODULE 3
		\node[module,#1,module opacity](r3-1) at (2*\modulexsep,0) {1};
		\node[below of=r3-1,yshift=0.75ex](r3-dots) {\vdots};
		\node[module,#1,module opacity,below of=r3-dots](r3-2) {\rthree};
		
		\foreach \i in {1,2}{
		   % INPUTS MODULE 3
			% just two modules
			\pgfmathsetmacro\rthreeintervalspace{1/(2+1)}
			\foreach \rthreeinput[evaluate=\rthreeinput as \rthreeinterval using \rthreeintervalspace*\rthreeinput] 
			in {1,2}
			\node[circle,draw,scale=0.1] (r3-\i-input-\rthreeinput)at($(r3-\i.north west)!\rthreeinterval!(r3-\i.south west)$)  {};
		  	
		  	% OUTPUTS MODULE 3	
		   % just two modules
			\pgfmathsetmacro\rthreeintervalspace{1/(2+1)}		
			\foreach \rthreeoutput[evaluate=\rthreeoutput as \rthreeinterval using \rthreeintervalspace*\rthreeoutput] 
			in {1,2}
			\draw ($(r3-\i.north east)!\rthreeinterval!(r3-\i.south east)+(0.5*\pinlength,0)$)node[scale=0.1](r3-\i-front output-\rthreeoutput){}--($(r3-\i.north east)!\rthreeinterval!(r3-\i.south east)$) node[circle,draw,scale=0.1] (r3-\i-output-\rthreeoutput) {};
		}
		
		% DRAWING CONNECTIONS
		%% from r1 to r2
		\foreach \startmodule in {1,2}{
		\foreach \conn in {1,2}
				\draw(r1-\startmodule-output-\conn)--(r2-\conn-input-\startmodule);
		}
		%% from r2 to r3
		\foreach \startmodule in {1,2}{
		\foreach \conn in {1,2}
				\draw(r3-\startmodule-input-\conn)--(r2-\conn-output-\startmodule);
		}
		
		% SETTING LABELS
		\node[below of=r1-2, set math mode labels] {\mone~\ensuremath{\times}~\rtwo};
		\node[below of=r2-2, set math mode labels] {\rone~\ensuremath{\times}~\rthree};
		\node[below of=r3-2, set math mode labels] {\rtwo~\ensuremath{\times}~\mthree};
		\draw[decorate,decoration={brace}]($(r1-2-front input-2)-(0.1,0)$)--($(r1-1-front input-1)-(0.1,0)$) node[midway,left=0.1cm, set math mode labels]{\N};
		\draw[decorate,decoration={brace}]($(r3-1-front output-1)+(0.1,0)$)--($(r3-2-front output-2)+(0.1,0)$) node[midway,right=0.1cm, set math mode labels]{\M};
	},
}

% CLOS EXAMPLE WITH LABELS

\tikzset{clos example with labels/.code={

      % Number of ports per module
      \pgfmathtruncatemacro{\mone}{\N/\rone}
      \pgfmathtruncatemacro{\mthree}{\M/\rthree}

		% COMPUTATION REAR CONDITION
		\pgfmathtruncatemacro\rtwo{max(\mone,\mthree)}
		
		% MODULE 1
		\node[module,#1,module opacity](r1-1) at (0,0) {1};
		\node[below of=r1-1,yshift=0.75ex](r1-dots) {\vdots};
		\node[module,#1,module opacity,below of=r1-dots](r1-2) {\ronelabel};
		
		\foreach \i in {1,2}{
		   % INPUTS MODULE 1	
		   % just two modules
			\pgfmathsetmacro\roneintervalspace{1/(2+1)}
			\foreach \roneinput[evaluate=\roneinput as \roneinterval using \roneintervalspace*\roneinput] 
			in {1,2}
			\draw ($(r1-\i.north west)!\roneinterval!(r1-\i.south west)-(0.5*\pinlength,0)$)node[scale=0.1](r1-\i-front input-\roneinput){}--($(r1-\i.north west)!\roneinterval!(r1-\i.south west)$) node[circle,draw,scale=0.1] (r1-\i-input-\roneinput) {};
			
			% OUTPUTS MODULE 1
			% just two modules
			\pgfmathsetmacro\roneintervalspace{1/(2+1)}
			\foreach \roneoutput[evaluate=\roneoutput as \roneinterval using \roneintervalspace*\roneoutput] 
			in {1,2}
			\node[circle,draw,scale=0.1] (r1-\i-output-\roneoutput)at($(r1-\i.north east)!\roneinterval!(r1-\i.south east)$)  {};
		}	
		
		% MODULE 2
		\node[module,#1,module opacity](r2-1) at (\modulexsep,0) {1};
		\node[below of=r2-1,yshift=0.75ex](r2-dots) {\vdots};
		\node[module,#1,module opacity,below of=r2-dots](r2-2) {\rtwolabel};
		
		\foreach \i in {1,2}{
		   % INPUTS MODULE 2
			% just two modules
			\pgfmathsetmacro\rtwointervalspace{1/(2+1)}
			\foreach \rtwoinput[evaluate=\rtwoinput as \rtwointerval using \rtwointervalspace*\rtwoinput] 
			in {1,2}
			\node[circle,draw,scale=0.1] (r2-\i-input-\rtwoinput)at($(r2-\i.north west)!\rtwointerval!(r2-\i.south west)$)  {};	
			
			% OUTPUTS MODULE 2
		   % just two modules
			\pgfmathsetmacro\rtwointervalspace{1/(2+1)}		
			\foreach \rtwooutput[evaluate=\rtwooutput as \rtwointerval using \rtwointervalspace*\rtwooutput] 
			in {1,2}
			\node[circle,draw,scale=0.1] (r2-\i-output-\rtwooutput)at ($(r2-\i.north east)!\rtwointerval!(r2-\i.south east)$) {};
		}
		
		% MODULE 3
		\node[module,#1,module opacity](r3-1) at (2*\modulexsep,0) {1};
		\node[below of=r3-1,yshift=0.75ex](r3-dots) {\vdots};
		\node[module,#1,module opacity,below of=r3-dots](r3-2) {\rthreelabel};
		
		\foreach \i in {1,2}{
		   % INPUTS MODULE 3
			% just two modules
			\pgfmathsetmacro\rthreeintervalspace{1/(2+1)}
			\foreach \rthreeinput[evaluate=\rthreeinput as \rthreeinterval using \rthreeintervalspace*\rthreeinput] 
			in {1,2}
			\node[circle,draw,scale=0.1] (r3-\i-input-\rthreeinput)at($(r3-\i.north west)!\rthreeinterval!(r3-\i.south west)$)  {};
		  	
		  	% OUTPUTS MODULE 3	
		   % just two modules
			\pgfmathsetmacro\rthreeintervalspace{1/(2+1)}		
			\foreach \rthreeoutput[evaluate=\rthreeoutput as \rthreeinterval using \rthreeintervalspace*\rthreeoutput] 
			in {1,2}
			\draw ($(r3-\i.north east)!\rthreeinterval!(r3-\i.south east)+(0.5*\pinlength,0)$)node[scale=0.1](r3-\i-front output-\rthreeoutput){}--($(r3-\i.north east)!\rthreeinterval!(r3-\i.south east)$) node[circle,draw,scale=0.1] (r3-\i-output-\rthreeoutput) {};
		}
		
		% DRAWING CONNECTIONS
		%% from r1 to r2
		\foreach \startmodule in {1,2}{
		\foreach \conn in {1,2}
				\draw(r1-\startmodule-output-\conn)--(r2-\conn-input-\startmodule);
		}
		%% from r2 to r3
		\foreach \startmodule in {1,2}{
		\foreach \conn in {1,2}
				\draw(r3-\startmodule-input-\conn)--(r2-\conn-output-\startmodule);
		}
		
		% SETTING LABELS
		\node[below of=r1-2,set math mode labels] {\monelabel~\ensuremath{\times}~\rtwolabel};
		\node[below of=r2-2,set math mode labels] {\ronelabel~\ensuremath{\times}~\rthreelabel};
		\node[below of=r3-2,set math mode labels] {\rtwolabel~\ensuremath{\times}~\mthreelabel};
		\draw[decorate,decoration={brace}]($(r1-2-front input-2)-(0.1,0)$)--($(r1-1-front input-1)-(0.1,0)$) node[midway,left=0.1cm,set math mode labels]{\Nlabel};
		\draw[decorate,decoration={brace}]($(r3-1-front output-1)+(0.1,0)$)--($(r3-2-front output-2)+(0.1,0)$) node[midway,right=0.1cm,set math mode labels]{\Mlabel};
	},
}

% BENES
% uses modules 2x2

% P is the number of input/output ports
\pgfmathtruncatemacro\P{8}%
\pgfkeys{/tikz/.cd, P/.initial=8}%
\pgfkeys{/tikz/.cd, P/.store in=\P}%

\tikzset{benes/.code={		

      % Number of ports per module
      \pgfmathtruncatemacro{\m}{2}
		
		% Numbers of modules in the second stage
		\pgfmathtruncatemacro\rtwo{\m}
		
		% Number of modules in the first/third stage
		\pgfmathtruncatemacro{\r}{\P/\m}
		
		\ifnum\P=4
		   \def\increment{0-\i*0.5*\r*\moduleysep}
		   \def\xincrement{\r*0.25*\modulexsep}
		\else
		   \def\increment{0-\i*0.39*\r*\moduleysep}
		   \def\xincrement{\r*0.2*\modulexsep}
		\fi

		% MODULE 1
		\foreach \i in {1,...,\r}{
		  	\path let \n1 = {int(0-\i)}, \n2={0-\i*\moduleysep}
		  	in
		  	node[module,#1,module opacity,yshift=1cm]  (r1-\i) at +(0,\n2) {\pgfmathparse{int(multiply(\n1,-1))}\pgfmathresult};
		  	
		  	% INPUTS MODULE 1	
		    % the number of inputs module one is exactly \mone
			\pgfmathsetmacro\roneintervalspace{1/(\m+1)}
			\foreach \roneinput[evaluate=\roneinput as \roneinterval using \roneintervalspace*\roneinput] 
			in {1,...,\m}
			\draw ($(r1-\i.north west)!\roneinterval!(r1-\i.south west)-(0.5*\pinlength,0)$)node[scale=0.1](r1-\i-front input-\roneinput){}--($(r1-\i.north west)!\roneinterval!(r1-\i.south west)$) node[circle,draw,scale=0.1] (r1-\i-input-\roneinput) {};
			
			% OUTPUTS MODULE 1
			% the number of outputs of module one is the number of modules stage 2 \rtwo
			\pgfmathsetmacro\roneintervalspace{1/(\rtwo+1)}
			\foreach \roneoutput[evaluate=\roneoutput as \roneinterval using \roneintervalspace*\roneoutput] 
			in {1,...,\rtwo}
			\node[circle,draw,scale=0.1] (r1-\i-output-\roneoutput)at($(r1-\i.north east)!\roneinterval!(r1-\i.south east)$)  {};
		}		  
      
		% MODULE 2
		\foreach \i in {1,...,\rtwo}{
		   
		  	\path let \n1 = {int(0-\i)}, \n2={\increment}
		  	in
		  	node[module extensible={\r*0.5*\modulesize},#1,module opacity,yshift=1cm]  (r2-\i) at +(\xincrement,\n2) {\pgfmathparse{int(multiply(\n1,-1))}\pgfmathresult};
		  			  	
		  	% INPUTS MODULE 2
			% the number of inputs of module two is the number of modules stage 1 \rone
			\pgfmathsetmacro\rtwointervalspace{1/(\r+1)}
			\foreach \rtwoinput[evaluate=\rtwoinput as \rtwointerval using \rtwointervalspace*\rtwoinput] 
			in {1,...,\r}
			\node[circle,draw,scale=0.1] (r2-\i-input-\rtwoinput)at($(r2-\i.north west)!\rtwointerval!(r2-\i.south west)$)  {};
			
			% OUTPUTS MODULE 2
		    % the number of outputs module two is exactly \rthree
			\pgfmathsetmacro\rtwointervalspace{1/(\r+1)}		
			\foreach \rtwooutput[evaluate=\rtwooutput as \rtwointerval using \rtwointervalspace*\rtwooutput] 
			in {1,...,\r}
			\node[circle,draw,scale=0.1] (r2-\i-output-\rtwooutput)at ($(r2-\i.north east)!\rtwointerval!(r2-\i.south east)$) {};
		  	
		}
		
		% MODULE 3
		\foreach \i in {1,...,\r}{
		  	\path let \n1 = {int(0-\i)}, \n2={0-\i*\moduleysep}
		  	in
		  	node[module,#1,module opacity,yshift=1cm]  (r3-\i) at +(2*\xincrement,\n2) {\pgfmathparse{int(multiply(\n1,-1))}\pgfmathresult};
		  	
		  	% INPUTS MODULE 3
			% the number of inputs of module three is the number of modules stage 2 \rtwo
			\pgfmathsetmacro\rthreeintervalspace{1/(\rtwo+1)}
			\foreach \rthreeinput[evaluate=\rthreeinput as \rthreeinterval using \rthreeintervalspace*\rthreeinput] 
			in {1,...,\rtwo}
			\node[circle,draw,scale=0.1] (r3-\i-input-\rthreeinput)at($(r3-\i.north west)!\rthreeinterval!(r3-\i.south west)$)  {};
		  	
		  	% OUTPUTS MODULE 3	
		    % the number of outputs module three is exactly \m
			\pgfmathsetmacro\rthreeintervalspace{1/(\m+1)}		
			\foreach \rthreeoutput[evaluate=\rthreeoutput as \rthreeinterval using \rthreeintervalspace*\rthreeoutput] 
			in {1,...,\m}
			\draw ($(r3-\i.north east)!\rthreeinterval!(r3-\i.south east)+(0.5*\pinlength,0)$)node[scale=0.1](r3-\i-front output-\rthreeoutput){}--($(r3-\i.north east)!\rthreeinterval!(r3-\i.south east)$) node[circle,draw,scale=0.1] (r3-\i-output-\rthreeoutput) {};			
		}
		
		% DRAWING CONNECTIONS
		%% from r1 to r2
		\foreach \startmodule in {1,...,\r}{
		\foreach \conn in {1,...,\rtwo}
				\draw(r1-\startmodule-output-\conn)--(r2-\conn-input-\startmodule);
		}
		%% from r2 to r3
		\foreach \startmodule in {1,...,\r}{
		\foreach \conn in {1,...,\rtwo}
				\draw(r3-\startmodule-input-\conn)--(r2-\conn-output-\startmodule);
		}
		
	}
}

% BENES COMPLETE

\tikzset{benes complete/.code={		

      % Number of ports per module
      \pgfmathtruncatemacro{\m}{2}
		
      % Number of modules in the first/third stage
      \pgfmathtruncatemacro{\r}{\P/\m}
      
      % Number of stages
      \pgfmathtruncatemacro{\stages}{2*round(log2(\P))-1}
      
      % MODULES for all stages
      \foreach \s [evaluate=\s as \numstage using int(\s-1)] in {1,...,\stages}{
      	\ifnum\s=1
      	% FIRST MODULE 
		\foreach \i in {1,...,\r}{
		  	\path let \n1 = {int(0-\i)}, \n2={0-\i*\moduleysep}
		  	in
		  	node[module,#1,module opacity,yshift=1cm]  (r\s-\i) at +(0,\n2) {\pgfmathparse{int(multiply(\n1,-1))}\pgfmathresult};
		  	
		  	% INPUTS MODULE 1	
		    % the number of inputs module one is exactly \mone
			\pgfmathsetmacro\roneintervalspace{1/(\m+1)}
			\foreach \roneinput[evaluate=\roneinput as \roneinterval using \roneintervalspace*\roneinput] 
			in {1,...,\m}
			\draw ($(r1-\i.north west)!\roneinterval!(r1-\i.south west)-(0.5*\pinlength,0)$)node[scale=0.1](r1-\i-front input-\roneinput){}--($(r1-\i.north west)!\roneinterval!(r1-\i.south west)$) node[circle,draw,scale=0.1] (r1-\i-input-\roneinput) {};
			
			% OUTPUTS MODULE 1
			% the number of outputs of module one is the number of modules stage 2
			\pgfmathsetmacro\roneintervalspace{1/(\m+1)}
			\foreach \roneoutput[evaluate=\roneoutput as \roneinterval using \roneintervalspace*\roneoutput] 
			in {1,...,\m}
			\node[circle,draw,scale=0.1] (r1-\i-output-\roneoutput)at($(r1-\i.north east)!\roneinterval!(r1-\i.south east)$)  {};
		}
      	\fi
      	\ifnum\s=\stages
		% FINAL MODULE 
		\foreach \i in {1,...,\r}{
		  	\path let \n1 = {int(0-\i)}, \n2={0-\i*\moduleysep}
		  	in
		  	node[module,#1,module opacity,yshift=1cm]  (r\s-\i) at +(\numstage*0.6*\modulexsep,\n2) {\pgfmathparse{int(multiply(\n1,-1))}\pgfmathresult};
		  	
		  	% INPUTS MODULE \s
			% the number of inputs of module three is the number of modules stage 2 \rtwo
			\pgfmathsetmacro\rintervalspace{1/(\m+1)}
			\foreach \rinput[evaluate=\rinput as \rinterval using \rintervalspace*\rinput] 
			in {1,...,\m}
			\node[circle,draw,scale=0.1] (r\s-\i-input-\rinput)at($(r\s-\i.north west)!\rinterval!(r\s-\i.south west)$)  {};
		  	
		  	% OUTPUTS MODULE \s
		    % the number of outputs module three is exactly \mthree
			\pgfmathsetmacro\rintervalspace{1/(\m+1)}		
			\foreach \routput[evaluate=\routput as \rinterval using \rintervalspace*\routput] 
			in {1,...,\m}
			\draw ($(r\s-\i.north east)!\rinterval!(r\s-\i.south east)+(0.5*\pinlength,0)$)node[scale=0.1](r\s-\i-front output-\routput){}--($(r\s-\i.north east)!\rinterval!(r\s-\i.south east)$) node[circle,draw,scale=0.1] (r\s-\i-output-\routput) {};			
		}
		\fi
		\pgfmathparse{and(\s>1,\s<\stages)}
		\let\cond\pgfmathresult
		\ifnum\cond=1 
		% INTERMEDIATE MODULEs 
		\foreach \i in {1,...,\r}{
		  	\path let \n1 = {int(0-\i)}, \n2={0-\i*\moduleysep}
		  	in
		  	node[module,#1,module opacity,yshift=1cm]  (r\s-\i) at +(\numstage*0.6*\modulexsep,\n2) {\pgfmathparse{int(multiply(\n1,-1))}\pgfmathresult};
		  	
		  	% INPUTS MODULE \s
			% the number of inputs of module three is the number of modules stage 2 \rtwo
			\pgfmathsetmacro\rintervalspace{1/(\m+1)}
			\foreach \rinput[evaluate=\rinput as \rinterval using \rintervalspace*\rinput] 
			in {1,...,\m}
			\node[circle,draw,scale=0.1] (r\s-\i-input-\rinput)at($(r\s-\i.north west)!\rinterval!(r\s-\i.south west)$)  {};
		  	
		  	% OUTPUTS MODULE \s
		    % the number of outputs module three is exactly \mthree
			\pgfmathsetmacro\rintervalspace{1/(\m+1)}		
			\foreach \routput[evaluate=\routput as \rinterval using \rintervalspace*\routput] 
			in {1,...,\m}
			\node[circle,draw,scale=0.1] (r\s-\i-output-\routput) at($(r\s-\i.north east)!\rinterval!(r\s-\i.south east)$)  {};			
		}
		\fi
      }
      
	}
}


\endinput
